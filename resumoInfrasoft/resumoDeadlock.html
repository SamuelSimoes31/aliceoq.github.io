<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Deadlock</title>
    </head>
    <body style="margin-left:100px">
        <a href="index.html">‚¨Ö voltar resum√£o</a>
        <h1>ü§ì RESUMO: Deadlock üíª</h1>
        <hr align="left" width="650px">
        <h2>Obten√ß√£o de recursos</h2>
        <ol>
            <li>Requisitar o recurso.</li>
            <li>Usar o recurso.</li>
            <li>Liberar o recurso.</li>
        </ol>
        <h2>O que √© um deadlock/impasse?</h2>
        <p>Uma situa√ß√£o onde todos os processos de um grupo
            esperam por eventos que somente outro processo do
            mesmo grupo pode fazer acontecer.</p>
        <p>Como todos est√£o esperando, nenhum evento esperado acontece.</p>
        <h2>Condi√ß√µes necess√°rias para a ocorr√™ncia de um deadlock</h2>
        <ol>
            <li>Exclus√£o m√∫tua.</li>
            <li>Posse e espera.</li>
            <li>N√£o preemp√ß√£o.</li>
            <li>Espera circular.</li>
        </ol>
        <h2>Modelagem de deadlocks</h2>
        <img src="images/modelagemDlock.png" alt="modelagemDlock">
        <h2>Estrat√©gias para lidar com deadlocks</h2>
        <ol>
            <li>Ignorar o problema.</li>
            <li>Detectar e recuperar. Deixar os impasses ocorrerem, detectar e recuperar.</li>
            <li>Evitar dinamicamente por meio de aloca√ß√£o cuidadosa de recursos.</li>
            <li>Prevenir, negando estruturalmente uma das quatro condi√ß√µes necess√°rias.</li>
        </ol>
        <h2>Detec√ß√£o de deadlocks</h2>
        <p>Duas estrat√©gias:</p>
        <ul>
            <li>Procurar processos bloqueados h√° muito tempo;</li>
            <li>Registrar aloca√ß√£o de recursos e verificar de h√° depend√™ncias circulares.</li>
        </ul>
        <h2>Algoritmo para detec√ß√£o de deadlocks</h2>
        <img src="images/deteccaoDlock.png" alt="deteccaoDlock">
        <p>Busca em profundidade (depth-first search).</p>
        <p>Aguarda uma √°rvore. Se durante a busca, encontrar
            novamente um n√≥ previamente visitado, gera um ciclo
            (deadlock).</p>
        <p>Se j√° visitou todas arestas de um dado n√≥, realiza
            backtrack para o n√≥ anterior. Ao realizar backtrack
            para raiz e n√£o conseguir continuar,  o subgrafo n√£o
            cont√©m ciclos.</p>
        <p>Se for v√°lido para todos os n√≥s, o grafo inteiro √© livre de ciclo.</p>
        <h2>Recupera√ß√£o de deadlocks</h2>
        <p>Recupera√ß√£o por elimina√ß√£o de processos.</p>
        <p>Recupera√ß√£o por retrocesso (rollback).</p>
        <h2>Evitando deadlocks</h2>
        <p>Alocar recursos de forma que deadlocks nunca aconte√ßam. Supondo que
            alguma informa√ß√£o sobre a necessidade de recursos est√° dispon√≠vel.</p>
        <p>ex: algoritmo do banqueiro.</p>
        <img src="images/banqueiro.png" alt="banqueiro">
        <h2>Preven√ß√£o de impasses</h2>
        <p>Pode ser realizada atacando a condi√ß√£o de:</p>
        <ul>
            <li>exclus√£o m√∫tua: spooling</li>
            <li>posse e espera: reserva de todos os recursos necess√°rios antes de travar</li>
            <li>n√£o-preemp√ß√£o: permitir que um processo ‚Äúroube temporariamente‚Äù um recurso de outro.</li>
            <li>espera circular: ordena√ß√£o num√©rica dos recursos.</li>
        </ul>
    </body>
</html>